package pl.edu.mimuw.nesc.codesize;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Range;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import pl.edu.mimuw.nesc.ast.Location;
import pl.edu.mimuw.nesc.ast.gen.DataDecl;
import pl.edu.mimuw.nesc.ast.gen.Declaration;
import pl.edu.mimuw.nesc.ast.gen.ExceptionVisitor;
import pl.edu.mimuw.nesc.ast.gen.ExtensionDecl;
import pl.edu.mimuw.nesc.ast.gen.FunctionDecl;
import pl.edu.mimuw.nesc.ast.gen.FunctionDeclarator;
import pl.edu.mimuw.nesc.ast.gen.InterfaceRefDeclarator;
import pl.edu.mimuw.nesc.ast.gen.NestedDeclarator;
import pl.edu.mimuw.nesc.ast.gen.VariableDecl;
import pl.edu.mimuw.nesc.astutil.AstUtils;
import pl.edu.mimuw.nesc.astutil.DeclaratorUtils;
import pl.edu.mimuw.nesc.astwriting.ASTWriter;
import pl.edu.mimuw.nesc.astwriting.WriteSettings;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * <p>Estimator of size of the code generated by SDCC compiler.</p>
 *
 * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
 */
public final class SDCCCodeSizeEstimator implements CodeSizeEstimator {
    /**
     * Name of the header file with non-banked functions declarations that will
     * be created.
     */
    private static final String NAME_NONBANKED_HEADER = "nonbanked_decls.h";

    /**
     * Name of the header file with banked functions declarations that will
     * be created for the estimation.
     */
    private static final String NAME_BANKED_HEADER = "banked_decls.h";

    /**
     * Name of the code segment that will contain the function whose size will
     * be estimated.
     */
    private static final String NAME_CODE_SEGMENT = "CODESEG";

    /**
     * Regular expression of a hexadecimal number.
     */
    private static final String REGEXP_HEX_NUMBER = "[0-9a-fA-F]+";

    /**
     * Regular expression for detecting the line with size of the code.
     */
    private static final Pattern REGEXP_LINE_CODE_SIZE = Pattern.compile("A "
            + NAME_CODE_SEGMENT + " size (?<size>" + REGEXP_HEX_NUMBER
            + ") flags " + REGEXP_HEX_NUMBER + " addr " + REGEXP_HEX_NUMBER);

    /**
     * Memory model used for compilation. If the object is absent, the default
     * memory model implied by SDCC is used.
     */
    private final Optional<SDCCMemoryModel> memoryModel;

    /**
     * Path to the SDCC executable.
     */
    private final String sdccExecutablePath;

    /**
     * Directory used for saving temporary SDCC files.
     */
    private final String tempDirectory;

    /**
     * Count of threads to use for the estimation.
     */
    private final int threadsCount;

    /**
     * Settings used for writing files.
     */
    private final WriteSettings writeSettings;

    /**
     * All declarations that constitute the program.
     */
    private final ImmutableList<Declaration> declarations;

    /**
     * Functions whose size will be estimated.
     */
    private final ImmutableList<FunctionDecl> functions;

    /**
     * Index of the next function whose code size will be estimated.
     */
    private final AtomicInteger nextFunIndex;

    /**
     * Array for storing results of the estimating operations.
     */
    private final AtomicReferenceArray<FunctionSizeEstimation> results;

    /**
     * Next index in the results array that is not used.
     */
    private final AtomicInteger nextResultIndex;

    /**
     * Result of the operation.
     */
    private Optional<ImmutableMap<String, Range<Integer>>> sizesEstimation;

    /**
     * Get a new builder that will build a SDCC code size estimator for given
     * declarations.
     *
     * @param declarations Declarations that constitute the program.
     * @param writeSettings Settings for writing the files during the estimation
     *                      operation.
     * @return Newly created builder that will build a SDCC code size estimator.
     */
    public static Builder builder(ImmutableList<Declaration> declarations, WriteSettings writeSettings) {
        checkNotNull(declarations, "declarations cannot be null");
        checkNotNull(writeSettings, "write settings cannot be null");
        return new Builder(declarations, writeSettings);
    }

    /**
     * Initializes this estimator using given builder.
     *
     * @param builder Builder that builds particular elements of a SDCC code
     *                size estimator.
     */
    private SDCCCodeSizeEstimator(PrivateBuilder builder) {
        this.memoryModel = builder.buildMemoryModel();
        this.sdccExecutablePath = builder.buildSDCCExecutablePath();
        this.tempDirectory = builder.buildTemporaryDirectory();
        this.threadsCount = builder.buildThreadsCount();
        this.declarations = builder.buildDeclarations();
        this.functions = builder.buildFunctions();
        this.writeSettings = builder.buildWriteSettings();
        this.nextFunIndex = new AtomicInteger(0);
        this.results = new AtomicReferenceArray<>(this.functions.size());
        this.nextResultIndex = new AtomicInteger(0);
        this.sizesEstimation = Optional.absent();
    }

    @Override
    public ImmutableMap<String, Range<Integer>> estimate() throws InterruptedException, IOException {
        if (sizesEstimation.isPresent()) {
            return sizesEstimation.get();
        }

        // Prepare the header files
        final ImmutableList<Declaration> headerDeclarations =
                createHeaderDeclarations();
        createHeaderFiles(headerDeclarations);

        // Create and start threads
        final Thread[] threads = new Thread[this.threadsCount - 1];
        for (int i = 0; i < threads.length; ++i) {
            threads[i] = new Thread(new EstimatingRunnable(i + 1), "estimate_thread" + (i + 1));
            threads[i].start();
        }

        // One of the estimating threads is the main thread
        new EstimatingRunnable(this.threadsCount).run();

        // Wait for all threads to finish
        for (Thread thread : threads) {
            thread.join();
        }

        // Check if all functions have been processed
        checkState(this.nextResultIndex.get() == this.functions.size(),
                "some estimation operations have failed");

        // Prepare the result
        sizesEstimation = Optional.of(createResultMap());
        return sizesEstimation.get();
    }

    private ImmutableList<Declaration> createHeaderDeclarations() {
        final ImmutableList.Builder<Declaration> headerDeclsBuilder = ImmutableList.builder();
        final HeaderDeclsCreatingVisitor headerDeclsVisitor = new HeaderDeclsCreatingVisitor();

        for (Declaration declaration : declarations) {
            headerDeclsBuilder.add(declaration.accept(headerDeclsVisitor, null));
        }

        return headerDeclsBuilder.build();
    }

    private void createHeaderFiles(ImmutableList<Declaration> headerDecls) throws IOException {
        createHeaderFile(Paths.get(tempDirectory, NAME_NONBANKED_HEADER).toString(), headerDecls, false);
        createHeaderFile(Paths.get(tempDirectory, NAME_BANKED_HEADER).toString(), headerDecls, true);
    }

    private void createHeaderFile(String fileName, ImmutableList<Declaration> headerDecls,
                boolean bankedFuns) throws IOException {
        // Set the flag in declarations
        final BankedFlagSettingVisitor bankedFlagVisitor = new BankedFlagSettingVisitor(bankedFuns);
        for (Declaration headerDecl : headerDecls) {
            headerDecl.accept(bankedFlagVisitor, null);
        }

        // Write the file
        try (final ASTWriter writer  = new ASTWriter(fileName, writeSettings)) {
            writer.write(headerDecls);
        }
    }

    private ImmutableMap<String, Range<Integer>> createResultMap() {
        final ImmutableMap.Builder<String, Range<Integer>> sizesMapBuilder =
                ImmutableMap.builder();

        for (int i = 0; i < results.length(); ++i) {
            final FunctionSizeEstimation estimation = results.get(i);
            sizesMapBuilder.put(estimation.functionName, Range.closed(estimation.minimumSize,
                    estimation.maximumSize));
        }

        return sizesMapBuilder.build();
    }

    /**
     * Code responsible for estimating sizes of functions.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private final class EstimatingRunnable implements Runnable {
        /**
         * Name of the file that will be used to save the function whose size
         * will be estimated.
         */
        private final String funFileName;

        /**
         * Name of the file that will contain the size of the function.
         */
        private final String relFileName;

        private EstimatingRunnable(int id) {
            checkArgument(id > 0, "identifier must be positive");
            this.funFileName = "fun" + id + ".c";
            this.relFileName = "fun" + id + ".rel";
        }

        @Override
        public void run() {
            for (int funIndex = nextFunIndex.getAndIncrement(); funIndex < functions.size();
                    funIndex = nextFunIndex.getAndIncrement()) {
                estimateSizeOf(functions.get(funIndex));
            }
        }

        private void estimateSizeOf(FunctionDecl functionDecl) {
            try {
                final int nonBankedSize = estimateSizeOf(functionDecl, false);
                final int bankedSize = estimateSizeOf(functionDecl, true);

                final int resultIndex = nextResultIndex.getAndIncrement();
                results.set(resultIndex, new FunctionSizeEstimation(DeclaratorUtils.getUniqueName(
                        functionDecl.getDeclarator()).get(), nonBankedSize, bankedSize));
            } catch (InterruptedException | IOException e) {
                throw new RuntimeException("cannot estimate size of function", e);
            }
        }

        private int estimateSizeOf(FunctionDecl functionDecl, boolean isBanked)
                        throws InterruptedException, IOException {
            // Write the file with the function
            writeFunctionFile(functionDecl, isBanked);

            // Run SDCC
            final String[] cmdArray = memoryModel.isPresent()
                    ? new String[] { sdccExecutablePath, memoryModel.get().getOption(), "-c", funFileName}
                    : new String[] { sdccExecutablePath, "-c", funFileName };
            final Process sdccProcess = Runtime.getRuntime().exec(cmdArray);
            final int sdccRetcode = sdccProcess.waitFor();
            if (sdccRetcode != 0) {
                throw new RuntimeException("SDCC returned code " + sdccRetcode);
            }

            // Read the size of the function from a file created by SDCC
            return readCodeSize();
        }

        private int readCodeSize() throws FileNotFoundException {
            try (final Scanner scanner = new Scanner(new FileInputStream(relFileName))) {
                while (scanner.hasNextLine()) {
                    final String line = scanner.nextLine();
                    final Matcher matcher = REGEXP_LINE_CODE_SIZE.matcher(line);

                    if (matcher.matches()) {
                        return Integer.valueOf(matcher.group("size"), 16);
                    }
                }
            }

            throw new RuntimeException("cannot find the size of the function after compiling by SDCC");
        }

        private void writeFunctionFile(FunctionDecl functionDecl, boolean isBanked) throws IOException {
            // Set the presence of '__banked' keyword
            DeclaratorUtils.setIsBanked(functionDecl.getDeclarator(), isBanked);

            try (final ASTWriter writer = new ASTWriter(funFileName, writeSettings)) {
                // Write the beginning of the file
                final String headerDeclsFile = isBanked
                        ? NAME_BANKED_HEADER
                        : NAME_NONBANKED_HEADER;
                writer.write("#include \"" + headerDeclsFile + "\"\n");
                writer.write("#pragma codeseg " + NAME_CODE_SEGMENT + "\n\n");

                // Write the function
                writer.write(functionDecl);
                writer.write('\n');
            }
        }
    }

    /**
     * Class that prepares declarations for header files. The returned
     * declaration is the declaration to include in the header file.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private static final class HeaderDeclsCreatingVisitor extends ExceptionVisitor<Declaration, Void> {
        @Override
        public Declaration visitDataDecl(DataDecl declaration, Void arg) {
            return declaration;
        }

        @Override
        public Declaration visitExtensionDecl(ExtensionDecl declaration, Void arg) {
            final Declaration newDeclaration = declaration.getDeclaration().accept(this, null);
            return newDeclaration != declaration.getDeclaration()
                    ? new ExtensionDecl(Location.getDummyLocation(), newDeclaration)
                    : declaration;
        }

        @Override
        public Declaration visitFunctionDecl(FunctionDecl declaration, Void arg) {
            return AstUtils.createForwardDeclaration(declaration);
        }
    }

    /**
     * Visitor that sets {@link FunctionDeclarator#isBanked isBanked} flag of
     * functions declared by visited declarations.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private static final class BankedFlagSettingVisitor extends ExceptionVisitor<Void, Void> {
        /**
         * Value of the flag to set.
         */
        private final boolean isBankedValue;

        private BankedFlagSettingVisitor(boolean isBankedValue) {
            this.isBankedValue = isBankedValue;
        }

        @Override
        public Void visitFunctionDecl(FunctionDecl declaration, Void arg) {
            DeclaratorUtils.setIsBanked(declaration.getDeclarator(), isBankedValue);
            return null;
        }

        @Override
        public Void visitExtensionDecl(ExtensionDecl declaration, Void arg) {
            declaration.getDeclaration().accept(this, null);
            return null;
        }

        @Override
        public Void visitDataDecl(DataDecl declaration, Void arg) {
            for (Declaration innerDeclaration : declaration.getDeclarations()) {
                innerDeclaration.accept(this, null);
            }
            return null;
        }

        @Override
        public Void visitVariableDecl(VariableDecl declaration, Void arg) {
            final Optional<NestedDeclarator> deepestNestedDeclarator =
                    DeclaratorUtils.getDeepestNestedDeclarator(declaration.getDeclarator());

            if (deepestNestedDeclarator.isPresent()
                    && deepestNestedDeclarator.get() instanceof FunctionDeclarator) {
                DeclaratorUtils.setIsBanked(declaration.getDeclarator().get(), isBankedValue);
            } else if (deepestNestedDeclarator.isPresent()
                    && deepestNestedDeclarator.get() instanceof InterfaceRefDeclarator) {
                throw new RuntimeException("unexpected interface reference declarator");
            }

            return null;
        }
    }

    /**
     * Helper class that allows storing a single estimate result.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private static final class FunctionSizeEstimation {
        private final String functionName;
        private final int minimumSize, maximumSize;

        private FunctionSizeEstimation(String functionName, int minimumSize, int maximumSize) {
            checkNotNull(functionName, "function name cannot be null");
            checkArgument(!functionName.isEmpty(), "function name cannot be an empty string");
            checkArgument(minimumSize > 0, "minimum size must be positive");
            checkArgument(maximumSize > 0, "maximum size must be positive");
            checkArgument(minimumSize <= maximumSize, "minimum size cannot be less than the maximum size");
            this.functionName = functionName;
            this.minimumSize = minimumSize;
            this.maximumSize = maximumSize;
        }
    }

    /**
     * Interface for building particular elements of a SDCC code size estimator.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private interface PrivateBuilder {
        Optional<SDCCMemoryModel> buildMemoryModel();
        String buildSDCCExecutablePath();
        String buildTemporaryDirectory();
        int buildThreadsCount();
        ImmutableList<Declaration> buildDeclarations();
        ImmutableList<FunctionDecl> buildFunctions();
        WriteSettings buildWriteSettings();
    }

    /**
     * Builder that collects data necessary for building an SDCC code size
     * estimator.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    public static final class Builder {
        /**
         * Data necessary for an SDCC code size estimator.
         */
        private final ImmutableList<Declaration> declarations;
        private final WriteSettings writeSettings;
        private Optional<SDCCMemoryModel> memoryModel;
        private Optional<String> sdccExecutablePath;
        private Optional<String> temporaryDirectory;
        private Optional<Integer> threadsCount;

        private Builder(ImmutableList<Declaration> declarations, WriteSettings writeSettings) {
            this.declarations = declarations;
            this.writeSettings = writeSettings;
            this.memoryModel = Optional.absent();
            this.sdccExecutablePath = Optional.absent();
            this.temporaryDirectory = Optional.absent();
            this.threadsCount = Optional.absent();
        }

        /**
         * Set the memory model used for estimating the code size. The argument
         * can be <code>null</code>. In such case the default model implied by
         * SDCC will be used.
         *
         * @param memoryModel Memory model to use for estimation.
         * @return <code>this</code>
         */
        public Builder memoryModel(SDCCMemoryModel memoryModel) {
            this.memoryModel = Optional.fromNullable(memoryModel);
            return this;
        }

        /**
         * Set path to SDCC executable that will be used to invoke it. The
         * argument can be <code>null</code>. In such case <code>sdcc</code>
         * command without any path will be used to invoke SDCC.
         *
         * @param executablePath Path to the SDCC executable.
         * @return <code>this</code>
         */
        public Builder sdccExecutable(String executablePath) {
            this.sdccExecutablePath = Optional.fromNullable(executablePath);
            return this;
        }

        /**
         * Set the directory used for storing files output by SDCC for
         * estimation of code size. The argument can be <code>null</code>.
         * In such case the default temporary directory will be used that
         * is provided by Java by using property "java.io.tmpdir".
         *
         * @param tmpDir Temporary directory to use.
         * @return <code>this</code>
         */
        public Builder temporaryDirectory(String tmpDir) {
            this.temporaryDirectory = Optional.fromNullable(tmpDir);
            return this;
        }

        /**
         * Set the number of additional threads that will be used for estimating
         * the code size. The argument must be positive.
         *
         * @param threadsCount Count of threads used for estimation.
         * @return <code>this</code>
         * @throws IllegalArgumentException Count of threads is not positive.
         */
        public Builder threadsCount(int threadsCount) {
            checkArgument(threadsCount > 0, "threads count must be positive");
            this.threadsCount = Optional.of(threadsCount);
            return this;
        }

        /**
         * Set the number of threads to use to the default value. The default
         * value is the count of cores in the system as obtained by calling
         * {@link java.lang.Runtime#availableProcessors}.
         *
         * @return <code>this</code>
         */
        public Builder defaultThreadsCount() {
            this.threadsCount = Optional.absent();
            return this;
        }

        private void validate() {
            // Check if the temporary directory exists and is writable
            if (temporaryDirectory.isPresent()) {
                final File tmpDir = new File(temporaryDirectory.get());
                checkState(tmpDir.exists(), "directory '" + temporaryDirectory.get()
                        + "' does not exist");
                checkState(tmpDir.isDirectory(), "'" + temporaryDirectory.get()
                        + "' is not a directory");
                checkState(tmpDir.canWrite(), "lack of write permission for '"
                        + temporaryDirectory.get() + "'");
            }
        }

        /**
         * Build a new SDCC code size estimator as configured in this builder.
         *
         * @return Newly created instance of an SDCC code size estimator.
         */
        public SDCCCodeSizeEstimator build() {
            validate();
            return new SDCCCodeSizeEstimator(new RealBuilder(memoryModel,
                    sdccExecutablePath, temporaryDirectory, threadsCount,
                    declarations,writeSettings));
        }
    }

    /**
     * Class that actually builds elements of an SDCC code size estimator.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private static final class RealBuilder extends ExceptionVisitor<Void, ImmutableList.Builder<FunctionDecl>>
                implements PrivateBuilder {
        /**
         * Default values of options for the estimator.
         */
        private static final String DEFAULT_SDCC_EXEC = "sdcc";
        private static final String DEFAULT_TMP_DIR = System.getProperty("java.io.tmpdir");
        private static final int DEFAULT_THREADS_COUNT = Runtime.getRuntime().availableProcessors();

        /**
         * Data neccesary to build the object.
         */
        private final Optional<SDCCMemoryModel> memoryModel;
        private final Optional<String> sdccExecutablePath;
        private final Optional<String> temporaryDirectory;
        private final Optional<Integer> threadsCount;
        private final ImmutableList<Declaration> declarations;
        private final WriteSettings writeSettings;

        private RealBuilder(Optional<SDCCMemoryModel> memoryModel, Optional<String> sdccExecutablePath,
                    Optional<String> temporaryDirectory, Optional<Integer> threadsCount,
                    ImmutableList<Declaration> declarations, WriteSettings writeSettings) {
            this.memoryModel = memoryModel;
            this.sdccExecutablePath = sdccExecutablePath;
            this.temporaryDirectory = temporaryDirectory;
            this.threadsCount = threadsCount;
            this.declarations = declarations;
            this.writeSettings = writeSettings;
        }

        @Override
        public Optional<SDCCMemoryModel> buildMemoryModel() {
            return memoryModel;
        }

        @Override
        public String buildSDCCExecutablePath() {
            return sdccExecutablePath.or(DEFAULT_SDCC_EXEC);
        }

        @Override
        public String buildTemporaryDirectory() {
            return temporaryDirectory.or(DEFAULT_TMP_DIR);
        }

        @Override
        public int buildThreadsCount() {
            return threadsCount.or(DEFAULT_THREADS_COUNT);
        }

        @Override
        public ImmutableList<Declaration> buildDeclarations() {
            return declarations;
        }

        @Override
        public ImmutableList<FunctionDecl> buildFunctions() {
            final ImmutableList.Builder<FunctionDecl> functionsBuilder =
                    ImmutableList.builder();

            for (Declaration declaration : declarations) {
                declaration.accept(this, functionsBuilder);
            }

            return functionsBuilder.build();
        }

        @Override
        public WriteSettings buildWriteSettings() {
            return writeSettings;
        }

        @Override
        public Void visitFunctionDecl(FunctionDecl declaration, ImmutableList.Builder<FunctionDecl> builder) {
            builder.add(declaration);
            return null;
        }

        @Override
        public Void visitExtensionDecl(ExtensionDecl declaration, ImmutableList.Builder<FunctionDecl> builder) {
            declaration.getDeclaration().accept(this, builder);
            return null;
        }

        @Override
        public Void visitDataDecl(DataDecl declaration, ImmutableList.Builder<FunctionDecl> builder) {
            return null;
        }
    }
}
