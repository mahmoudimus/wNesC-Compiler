package pl.edu.mimuw.nesc.codesize;

import com.google.common.base.Optional;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Range;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.Paths;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReferenceArray;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import pl.edu.mimuw.nesc.ast.gen.Declaration;
import pl.edu.mimuw.nesc.ast.gen.FunctionDecl;
import pl.edu.mimuw.nesc.astutil.DeclaratorUtils;
import pl.edu.mimuw.nesc.astwriting.ASTWriter;
import pl.edu.mimuw.nesc.astwriting.CustomDeclarationsWriter;
import pl.edu.mimuw.nesc.astwriting.WriteSettings;
import pl.edu.mimuw.nesc.common.util.VariousUtils;
import pl.edu.mimuw.nesc.external.ExternalConstants;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * <p>Estimator of size of the code generated by SDCC compiler.</p>
 *
 * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
 */
final class UnitarySDCCCodeSizeEstimator implements CodeSizeEstimator {
    /**
     * Name of the header file with non-banked functions declarations that will
     * be created.
     */
    private static final String NAME_NONBANKED_HEADER = "nonbanked_decls.h";

    /**
     * Name of the header file with banked functions declarations that will
     * be created for the estimation.
     */
    private static final String NAME_BANKED_HEADER = "banked_decls.h";

    /**
     * Name of the code segment that will contain the function whose size will
     * be estimated.
     */
    private static final String NAME_CODE_SEGMENT = "CODESEG";

    /**
     * Regular expression of a hexadecimal number.
     */
    private static final String REGEXP_HEX_NUMBER = "[0-9a-fA-F]+";

    /**
     * Regular expression for detecting the line with size of the code.
     */
    private static final Pattern REGEXP_LINE_CODE_SIZE = Pattern.compile("A "
            + NAME_CODE_SEGMENT + " size (?<size>" + REGEXP_HEX_NUMBER
            + ") flags " + REGEXP_HEX_NUMBER + " addr " + REGEXP_HEX_NUMBER);

    /**
     * Memory model used for compilation. If the object is absent, the default
     * memory model implied by SDCC is used.
     */
    private final Optional<SDCCMemoryModel> memoryModel;

    /**
     * Path to the SDCC executable.
     */
    private final String sdccExecutablePath;

    /**
     * Parameters to pass to SDCC.
     */
    private final ImmutableList<String> sdccParameters;

    /**
     * Directory used for saving temporary SDCC files.
     */
    private final String tempDirectory;

    /**
     * Count of threads to use for the estimation.
     */
    private final int threadsCount;

    /**
     * Settings used for writing files.
     */
    private final WriteSettings writeSettings;

    /**
     * All declarations that constitute the program.
     */
    private final ImmutableList<Declaration> declarations;

    /**
     * Functions whose size will be estimated.
     */
    private final ImmutableList<FunctionDecl> functions;

    /**
     * Index of the next function whose code size will be estimated.
     */
    private final AtomicInteger nextFunIndex;

    /**
     * Array for storing results of the estimating operations.
     */
    private final AtomicReferenceArray<FunctionSizeEstimation> results;

    /**
     * Next index in the results array that is not used.
     */
    private final AtomicInteger nextResultIndex;

    /**
     * Result of the operation.
     */
    private Optional<CodeSizeEstimation> sizesEstimation;

    UnitarySDCCCodeSizeEstimator(
            ImmutableList<Declaration> declarations,
            ImmutableList<FunctionDecl> functions,
            String sdccExecutablePath,
            ImmutableList<String> sdccParameters,
            Optional<SDCCMemoryModel> memoryModel,
            String tempDirectory,
            int threadsCount,
            WriteSettings writeSettings
    ) {
        checkNotNull(declarations, "declarations cannot be null");
        checkNotNull(functions, "functions cannot be null");
        checkNotNull(sdccExecutablePath, "SDCC executable path cannot be null");
        checkNotNull(sdccParameters, "SDCC parameters cannot be null");
        checkNotNull(memoryModel, "SDCC memory model cannot be null");
        checkNotNull(tempDirectory, "temporary directory cannot be null");
        checkNotNull(writeSettings, "write settings cannot be null");
        checkArgument(!sdccExecutablePath.isEmpty(), "SDCC executable path cannot be an empty string");
        checkArgument(!tempDirectory.isEmpty(), "temporary directory cannot be null");
        checkArgument(threadsCount > 0, "threads count must be positive");

        this.memoryModel = memoryModel;
        this.sdccExecutablePath = sdccExecutablePath;
        this.sdccParameters = sdccParameters;
        this.tempDirectory = tempDirectory;
        this.threadsCount = threadsCount;
        this.declarations = declarations;
        this.functions = functions;
        this.writeSettings = writeSettings;
        this.nextFunIndex = new AtomicInteger(0);
        this.results = new AtomicReferenceArray<>(this.functions.size());
        this.nextResultIndex = new AtomicInteger(0);
        this.sizesEstimation = Optional.absent();
    }

    @Override
    public CodeSizeEstimation estimate() throws InterruptedException, IOException {
        if (sizesEstimation.isPresent()) {
            return sizesEstimation.get();
        }

        // Prepare the header files
        createHeaderFiles();

        // Create and start threads
        final Thread[] threads = new Thread[this.threadsCount - 1];
        for (int i = 0; i < threads.length; ++i) {
            threads[i] = new Thread(new EstimatingRunnable(i + 1), "estimate_thread" + (i + 1));
            threads[i].start();
        }

        // One of the estimating threads is the main thread
        new EstimatingRunnable(this.threadsCount).run();

        // Wait for all threads to finish
        for (Thread thread : threads) {
            thread.join();
        }

        // Check if all functions have been processed
        checkState(this.nextResultIndex.get() == this.functions.size(),
                "some estimation operations have failed");

        // Prepare the result
        sizesEstimation = Optional.of(createResultEstimation());
        return sizesEstimation.get();
    }

    private void createHeaderFiles() throws IOException {
        // Write non-banked declarations
        final CustomDeclarationsWriter declsWriter = new CustomDeclarationsWriter(
                Paths.get(tempDirectory, NAME_NONBANKED_HEADER).toString(),
                true,
                CustomDeclarationsWriter.Banking.DEFINED_NOT_BANKED,
                writeSettings
        );
        declsWriter.setPrependedText(Optional.of(ExternalConstants.getExternalDefines()));
        declsWriter.write(declarations);

        // Write banked declarations
        declsWriter.setOutputFile(Paths.get(tempDirectory, NAME_BANKED_HEADER).toString());
        declsWriter.setBanking(CustomDeclarationsWriter.Banking.DEFINED_BANKED);
        declsWriter.write(declarations);
    }

    private CodeSizeEstimation createResultEstimation() {
        final CodeSizeEstimation.Builder estimationBuilder = CodeSizeEstimation.builder();

        for (int i = 0; i < results.length(); ++i) {
            final FunctionSizeEstimation estimation = results.get(i);
            estimationBuilder.putFunctionSize(estimation.functionName, Range.closed(
                    estimation.minimumSize, estimation.maximumSize));
        }

        return estimationBuilder.build();
    }

    /**
     * Code responsible for estimating sizes of functions.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private final class EstimatingRunnable implements Runnable {
        /**
         * Name of the file that will be used to save the function whose size
         * will be estimated.
         */
        private final String funFileName;

        /**
         * Name of the file that will contain the size of the function.
         */
        private final String relFileName;

        /**
         * Builder for the SDCC process that will be reused.
         */
        private final ProcessBuilder sdccProcessBuilder;

        private EstimatingRunnable(int id) {
            checkArgument(id > 0, "identifier must be positive");

            this.funFileName = Paths.get(tempDirectory, "fun" + id + ".c").toString();
            this.relFileName = Paths.get(tempDirectory, "fun" + id + ".rel").toString();

            // Create command invocation for SDCC
            final List<String> sdccCmdList = new LinkedList<>();
            sdccCmdList.add(sdccExecutablePath);
            if (memoryModel.isPresent()) {
                sdccCmdList.add(memoryModel.get().getOption());
            }
            sdccCmdList.add("-c");
            sdccCmdList.add("-mmcs51");
            sdccCmdList.addAll(sdccParameters);
            sdccCmdList.add(funFileName);

            // Configure the SDCC process builder
            this.sdccProcessBuilder = new ProcessBuilder(sdccCmdList)
                    .directory(new File(tempDirectory))
                    .redirectErrorStream(true);
        }

        @Override
        public void run() {
            for (int funIndex = nextFunIndex.getAndIncrement(); funIndex < functions.size();
                    funIndex = nextFunIndex.getAndIncrement()) {
                estimateSizeOf(functions.get(funIndex));
            }
        }

        private void estimateSizeOf(FunctionDecl functionDecl) {
            try {
                final int nonBankedSize = estimateSizeOf(functionDecl, false);
                final int bankedSize = estimateSizeOf(functionDecl, true);

                final int resultIndex = nextResultIndex.getAndIncrement();
                results.set(resultIndex, new FunctionSizeEstimation(DeclaratorUtils.getUniqueName(
                        functionDecl.getDeclarator()).get(), nonBankedSize, bankedSize));
            } catch (InterruptedException | IOException e) {
                throw new RuntimeException("cannot estimate size of function", e);
            }
        }

        private int estimateSizeOf(FunctionDecl functionDecl, boolean isBanked)
                        throws InterruptedException, IOException {
            // Write the file with the function
            writeFunctionFile(functionDecl, isBanked);

            // Run SDCC
            final Process sdccProcess = sdccProcessBuilder.start();
            final int sdccRetcode = VariousUtils.waitForProcessHandlingIO(sdccProcess);
            if (sdccRetcode != 0) {
                throw new RuntimeException("SDCC returned code " + sdccRetcode);
            }

            // Read the size of the function from a file created by SDCC
            return readCodeSize();
        }

        private int readCodeSize() throws FileNotFoundException {
            try (final Scanner scanner = new Scanner(new FileInputStream(relFileName))) {
                while (scanner.hasNextLine()) {
                    final String line = scanner.nextLine();
                    final Matcher matcher = REGEXP_LINE_CODE_SIZE.matcher(line);

                    if (matcher.matches()) {
                        return Integer.valueOf(matcher.group("size"), 16);
                    }
                }
            }

            throw new RuntimeException("cannot find the size of the function after compiling by SDCC");
        }

        private void writeFunctionFile(FunctionDecl functionDecl, boolean isBanked) throws IOException {
            // Set the presence of '__banked' keyword
            DeclaratorUtils.setIsBanked(functionDecl.getDeclarator(), isBanked);

            try (final ASTWriter writer = new ASTWriter(funFileName, writeSettings)) {
                // Write the beginning of the file
                final String headerDeclsFile = isBanked
                        ? NAME_BANKED_HEADER
                        : NAME_NONBANKED_HEADER;
                writer.write("#include \"" + headerDeclsFile + "\"\n");
                writer.write("#pragma codeseg " + NAME_CODE_SEGMENT + "\n\n");

                // Write the function
                writer.write(functionDecl);
                writer.write('\n');
            }
        }
    }

    /**
     * Helper class that allows storing a single estimate result.
     *
     * @author Michał Ciszewski <michal.ciszewski@students.mimuw.edu.pl>
     */
    private static final class FunctionSizeEstimation {
        private final String functionName;
        private final int minimumSize, maximumSize;

        private FunctionSizeEstimation(String functionName, int minimumSize, int maximumSize) {
            checkNotNull(functionName, "function name cannot be null");
            checkArgument(!functionName.isEmpty(), "function name cannot be an empty string");
            checkArgument(minimumSize > 0, "minimum size must be positive");
            checkArgument(maximumSize > 0, "maximum size must be positive");
            checkArgument(minimumSize <= maximumSize, "minimum size cannot be less than the maximum size");
            this.functionName = functionName;
            this.minimumSize = minimumSize;
            this.maximumSize = maximumSize;
        }
    }
}
